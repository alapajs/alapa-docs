"use strict";(self.webpackChunkalapa_doc=self.webpackChunkalapa_doc||[]).push([[9736],{4490:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-docs/generate","title":"Generate","description":"Alapa offers a set of powerful decorators that allow developers to automatically generate API documentation in a clean, consistent,","source":"@site/docs/api-docs/generate.mdx","sourceDirName":"api-docs","slug":"/api-docs/generate","permalink":"/docs/api-docs/generate","draft":false,"unlisted":false,"editUrl":"https://github.com/alapajs/alapa-docs/tree/main/docs/api-docs/generate.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Generate"},"sidebar":"tutorialSidebar","previous":{"title":"Database Configuration","permalink":"/docs/model/config"},"next":{"title":"Schema","permalink":"/docs/api-docs/schema"}}');var s=r(4848),o=r(8453);const a={sidebar_position:1,title:"Generate"},i="Generate API Documentation",d={},c=[{value:"Introduction to Alapa&#39;s API Documentation Decorators",id:"introduction-to-alapas-api-documentation-decorators",level:2},{value:"Key Decorators",id:"key-decorators",level:2},{value:"1. <code>@OpenApiOperation</code>",id:"1-openapioperation",level:3},{value:"Example:",id:"example",level:4},{value:"2. <code>@OpenApiPathMethod</code>",id:"2-openapipathmethod",level:3},{value:"Example:",id:"example-1",level:4},{value:"3. <code>@OpenApiPath</code>",id:"3-openapipath",level:3},{value:"Example:",id:"example-2",level:4},{value:"Summary",id:"summary",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components},{BrowserWindow:t,CodeScreen:a}=n;return t||h("BrowserWindow",!0),a||h("CodeScreen",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"generate-api-documentation",children:"Generate API Documentation"})}),"\n",(0,s.jsx)(n.p,{children:"Alapa offers a set of powerful decorators that allow developers to automatically generate API documentation in a clean, consistent,\r\nand maintainable way. These decorators are designed to work seamlessly with Alapa's routing and controller system, which means you\r\ncan focus on building the application\u2019s core features without worrying about the tedious task of maintaining accurate and up-to-date\r\nAPI documentation."}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-alapas-api-documentation-decorators",children:"Introduction to Alapa's API Documentation Decorators"}),"\n",(0,s.jsx)(n.p,{children:"Alapa's decorators are designed to streamline the process of documenting APIs by allowing developers to define OpenAPI specifications directly within their code. This approach ensures that the documentation is always in sync with the actual implementation, reducing the risk of discrepancies and making it easier to maintain."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"key-decorators",children:"Key Decorators"}),"\n",(0,s.jsxs)(n.h3,{id:"1-openapioperation",children:["1. ",(0,s.jsx)(n.code,{children:"@OpenApiOperation"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@OpenApiOperation"})," decorator is used to define OpenAPI specifications for individual methods within a controller or resourceful\r\nclass. It is particularly useful for documenting methods where the HTTP method and path are automatically generated by Alapa's\r\nrouting system. This decorator automatically binds the OpenAPI definition to the method's HTTP verb and route."]}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(a,{title:"src/api/users/Controller.ts",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { Controller, OpenApiOperation, Request, Response } from "alapa";\r\nimport { Users } from "../../models/user";\r\n\r\nexport class UserController extends Controller {\r\n  @OpenApiOperation({\r\n    summary: "Get users",\r\n    description: "Get all users",\r\n  })\r\n  async getIndex(req: Request, res: Response) {\r\n    const users = Users.find();\r\n    res.api({\r\n      status: "success",\r\n      data: users,\r\n      message: "Users retrieved successfully",\r\n    });\r\n  }\r\n}\n'})})}),"\n",(0,s.jsx)(t,{title:"/docs/#/UserController/get-users",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"OpenApiOperation",src:r(990).A+"",width:"1792",height:"769"})})}),"\n",(0,s.jsxs)(n.h3,{id:"2-openapipathmethod",children:["2. ",(0,s.jsx)(n.code,{children:"@OpenApiPathMethod"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@OpenApiPathMethod"})," decorator is used to define multiple HTTP methods (e.g., ",(0,s.jsx)(n.code,{children:"GET"}),", ",(0,s.jsx)(n.code,{children:"POST"}),", ",(0,s.jsx)(n.code,{children:"PUT"}),", ",(0,s.jsx)(n.code,{children:"DELETE"}),") for the same endpoint.\r\nThis is particularly useful when a single route supports multiple operations, and you want to document them in one place."]}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,s.jsx)(a,{title:"src/api/users/Controller.ts",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { Controller, OpenApiPathMethod, Request, Response } from "alapa";\r\nimport { Users } from "../../models/user";\r\n\r\nexport class UserController extends Controller {\r\n  @OpenApiPathMethod({\r\n    get: {\r\n      summary: "Show a user",\r\n      description: "Shows a user",\r\n      responses: {\r\n        200: {\r\n          description: "User retrieved",\r\n          content: {\r\n            "application/json": {\r\n              schema: {\r\n                type: "object",\r\n                properties: {\r\n                  id: { type: "integer" },\r\n                  name: { type: "string" },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n    post: {\r\n      summary: "Create a user",\r\n      description: "Creates a new user",\r\n      requestBody: {\r\n        required: true,\r\n        content: {\r\n          "application/json": {\r\n            schema: {\r\n              type: "object",\r\n              properties: {\r\n                name: { type: "string" },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n  async getIndex(req: Request, res: Response) {\r\n    if (req.method === "GET") {\r\n      const users = await Users.find();\r\n      res.api({\r\n        status: "success",\r\n        data: users,\r\n        message: "Users retrieved successfully",\r\n      });\r\n    } else if (req.method === "post") {\r\n      // Handle POST requests\r\n    }\r\n  }\r\n}\n'})})}),"\n",(0,s.jsx)(t,{title:"/docs/#/UserController/post-users",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"OpenApiOperation",src:r(382).A+"",width:"1797",height:"707"})})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"3-openapipath",children:["3. ",(0,s.jsx)(n.code,{children:"@OpenApiPath"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@OpenApiPath"})," decorator is used to define OpenAPI documentation for a specific route path and its associated HTTP methods. It allows you to document an entire endpoint, including all supported methods, in one place."]}),"\n",(0,s.jsx)(n.h4,{id:"example-2",children:"Example:"}),"\n",(0,s.jsx)(a,{title:"src/api/users/Controller.ts",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { Controller, OpenApiPath, Request, Response } from "alapa";\r\n\r\nexport class PostController extends Controller {\r\n  @OpenApiPath("/api/post/{id}", {\r\n    get: {\r\n      summary: "Fetch data",\r\n      description: "Fetches data from the API",\r\n      parameters: [\r\n        {\r\n          name: "id",\r\n          in: "path",\r\n          required: true,\r\n        },\r\n      ],\r\n      responses: {\r\n        200: {\r\n          description: "Data retrieved",\r\n          content: {\r\n            "application/json": {\r\n              schema: {\r\n                type: "object",\r\n                properties: {\r\n                  title: { type: "string" },\r\n                  body: { type: "string" },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n  test(req: Request, res: Response) {\r\n    const id = req.params.id;\r\n    res.json({\r\n      title: "Sample Post Title",\r\n      body: `Lorem ipsum dolor sit amet, consectetur adipiscing elit.`,\r\n    });\r\n  }\r\n}\n'})})}),"\n",(0,s.jsx)(t,{title:"/docs/#/UserController/post-users",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"OpenApiOperation",src:r(3480).A+"",width:"1783",height:"907"})})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["Alapa's decorators provide a powerful and flexible way to generate API documentation directly within your code. By using ",(0,s.jsx)(n.code,{children:"@OpenApiOperation"}),", ",(0,s.jsx)(n.code,{children:"@OpenApiPathMethod"}),", and ",(0,s.jsx)(n.code,{children:"@OpenApiPath"}),", you can ensure that your documentation is always accurate, up-to-date, and easy to maintain. These tools not only save time but also improve the overall quality and consistency of your API documentation."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},382:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/example-method-b1152ce6fb88836affe2b7484280e420.png"},990:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/example-operation-3c314737fb91d3525ca4ccfb3c3dd2ed.png"},3480:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/example-path-f5a00aa48a7abada59535bb5cbfad7bf.png"},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);